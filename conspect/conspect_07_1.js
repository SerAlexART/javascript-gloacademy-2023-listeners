'use strict';

// * Объекты
// Созданы для того, что хранить в себе целыую коллекцию данных разных типов, будь то строки, числа, Массивы и объекты.

// Обычную переменную мы можем воспринимать как обычную коробку, которая имеет подпись/имя и внутри какой-то предмет/значение. Каждая переменная может хранить своё значение только в однои типе, этот тип можно менять.

// Объект можно представить как целую комнату с коробками.

// Все данные внутри себя объекта содержит в виде пары ключ:значение
let name_1 = 'Ser';

// Создание объекта способ №1 - чаше используется этот вариант
let person_1 = {
    name_1_1: 'Ser',
    // name - ключ/свойство;
    // : - оператор присваивания;
    // 'Ser' - значение

    name_1_2: name_1, // Можно указывать переменную

    'name-1-3': 'Ser' // Название свойства можно задавать в виде строки. Полезно, когда в названии свойства нужно использовать тире -
};

// Создание объекта способ №2 - испоользуется крайне редко
let job_1 = new Object();




// Создать свойство внутри объекта мы можем разными способами
person_1.age = 31; // В комнату с названием person1, в коробку с надписью age в которой хранится значение 31

job_1.position = 'developer'; // К объекту, который был создан через конструктор new Object() свойство добавляет таким же способом

//
person_1.job_1_1 = job_1; // Внутри объекта можно передавать в виде свойства другие объекты


console.log(name_1);
console.log(person_1);

// Чтобы получить значение свойства объекта нам необходима точечная нотация. То-есть мы можем достать из коробки значения
console.log(person_1.age);

// Ещё способ достать значение из коробки через [], а название ключа необходимо передавать в виде строки через ''
console.log(person_1['age']);

console.log(job_1);
console.log(job_1.position);
console.log(person_1.job_1_1);

console.log(person_1.job_1_1 === job_1); // Получим истину, так как вложенный объект равен тому объекту, который мы вложили, но person1.job1_1 является не совсем объектом, об этом ниже




// * Давайте в абстракции попробуем представить всю ситуацию, что у нас есть в коде
// Есть два абсолютно разных объекта person_2 и job_2. Объекты не копируются, они оставляют ссылку на которую мы ссылаем. Если мы изменим свойство position_2_1 внутри job_2, то оно изменится и у свойства job_2_1 у объекта person_2. Или если внутри job_2 объявим новое свойство sallary: '1.000.000', то оно появится и у person_2
let person_2 = {
    name_2_1: 'Ser',
    age_2_1: 31
};

let job_2 = {
    position_2_1: 'developer'
};

person_2.job_2_1 = job_2; // Объект внутри person_2 зависит от объекта job_2
person_2.job_2_1.position_2_1 = 'middle developer'; // Меняем значение свойства position_2_1 у объекта person_2 и у job_2

console.log(person_2);
console.log(job_2);
console.log(person_2.age_2_1);
console.log(person_2['age_2_1']);
console.log(person_2.job_2_1 === job_2);

// * Можем создать объект внутри объекта
let person_3 = {
    name_3_1: 'Ser',
    age_3_1: 31,
    job_3_1: { // Объект внутри объекта
        position_3_1: 'seniory-developer',
        sallary_3_1: '255.000'
    }
};

console.log(person_3);




// * Объект может содержать функцию - функция внутри объекта называется Метод
let key_5 = 'city_5_1';
let city_5 = 'Saint Petersburg';
let person_4 = {
    name_4_1: 'Ser',
    age_4_1: 31,
    job_4_1: { // Объект внутри объекта
        position_4_1: 'seniory-developer',
        sallary_4_1: '255.000'
    },
    say_4_3: function (str) { // Можно сразу создать функцию при инициализации объекта
        console.log(str);
    },
    [key_5]: city_5 // Создаём ключ и значение из переменных через [] сразу при прициализации объекта
};

const say_4 = function (str) { // Создаём функцию
    console.log(str);
};

person_4.say_4_1 = say_4; // Создаём новое свойство say_4_1 и передаём в него функцию say_4

person_4.say_4_2 = function (str) { // Можно напрямую создать новое свойство say_4_2 и передать в него функцию
    console.log(str);
};

person_4.say_4_1('Saaaaaay!'); // Вызываем функцию передав строку 'Saaaaaay!'
person_4.say_4_2('Saaaaaay_2!'); // Вызываем функцию передав строку 'Saaaaaay_2!'
person_4.say_4_3('Saaaaaay_3!'); // Вызываем функцию передав строку 'Saaaaaay_3!'
person_4[key_5] = city_5; // Создаём ключ и значение из переменных через []

console.log(person_4);



// * Массив - у объектов есть разные разновидности, в том числе как и Массив
// Массив, как и объект, может хранить внутри себя разные типаы данных. От объекта его отличает то, что вместо именного ключа он использует порядковый индекс, который всегда начинается с 0. Вместо ключа в Массиве идёт 0, 1, 2, 3 ...

// По сути мы взяли объект, видоизменили и переработали его набор параметров, свойств и методов, чтобы было удобнее с ним работать и в итоге получился Массив

// * Создание Массива через [] - чаще всего используется этот способ
let array_1 = [1, 2, 3, 4, 5];

// Благодаря [] мы можем записывать информацию в Массив
array_1[5] = 'Five';

// Попробуем добавить в Массив элемент с индексом 10, что добавит его и создат в промежутке пустые элементы Массива. Они будут определены, но только без значений
array_1[10] = 'У меня индекс 10';

console.log(array_1);
console.log(array_1[0]); // Обращаемся к индексу 2 из Массива, вернёт число 1
console.log(array_1[7]); // Обращаемся к индексу 7 из Массива, вернёт undefined
console.log(array_1[10]); // Обращаемся к индексу 10 из Массива, вернёт 10, так как ранее мы добавили в индекс 10 какое-то значение
console.log('Длина Массива = ' + array_1.length);

// * Массивы можно создавать из контрускторов как и объект
let array_2_1 = new Array(); // Можно создать пустой Массив
let array_2_2 = new Array(1, 2, 3, 4, 5); // Можно создать Массив с значениями
let array_2_3 = new Array(5); // Если создать Массив ТОЛЬКО с одним значением, то это значение будет длинной Массива

console.log(array_2_1);
console.log(array_2_2);
console.log(array_2_3);
console.log(array_2_3.length);

// * При создании Массива можно указывать пустые элементы - на практике не встречается или очень-очень редко
let array_3 = [, , , , 5];

console.log(array_3);

// * Можно принудительно указать длину нашего Массива - а вот этот способ на практике встречается довольно часто
let array_4 = [, , , , 5];

array_4.length = 22; // Указываем длину Массива
// array_4.length = 0; // Указываем длину Массива 0 и получим пустой Массив, называется очисткой Массива

console.log(array_4);
console.log(array_4.length);


// * Основные методы для работы с Массивами - !!! эти методы действительно меняют исходный Массив, но не все методы меняют Массив
// 1. push - добавляет элемент в самый конец Массива !!! МЕНЯЮТ !!!
// 2. unshift - добавляет элемент в самое начало Массива !!! МЕНЯЮТ !!!
let array_5_1 = ['Dark Souls', 'Bloodborde', 'Elden Ring'];
let array_5_2 = ['Dark Souls', 'Bloodborde', 'Elden Ring'];

array_5_1.push('Last game');
array_5_1.unshift('First game', 'Demons Souls');

// 3. pop - удаляет элемент из Массива с самого конца !!! МЕНЯЮТ и ВОЗВРАЩАЮТ !!!
// 4. shift - удаляет элемент из Массива с самого начала !!! МЕНЯЮТ и ВОЗВРАЩАЮТ !!!
// Эти методы возвращают значение первого или последнего элементов, например мы можем вывести их в консоль. Эти методы как буд-то вырезают из Массива определённую часть и возвращают
let lastElemet_5_1 = array_5_1.pop();

array_5_1.pop();
array_5_1.shift();

// 5. sort - помогает сортировать элементы в Массиве
array_5_2.sort();

console.log(array_5_1);
console.log(array_5_1.length);
console.log(array_5_1.pop());
console.log(array_5_1.shift());
console.log(lastElemet_5_1);

console.log(array_5_2);
console.log(array_5_2[0]);

// 6. reverse - зеркалит
array_5_2.reverse();
console.log(array_5_2);
console.log(array_5_2[0]);


// * 7. join - не меняет Массив и возвращает элемент как строку. !!! ТОЛЬКО ВОЗВРАЩАЕТ !!!
console.log(array_5_2.join()); // Разделитель по умолчанию ,
console.log(array_5_2.join(' ')); // Можно изменить раздтелитель
console.log(array_5_2.join(', ')); // Можно изменить раздтелитель




// * Варианты перебора Объектов и Массивов
let obj_1 = {
    name_1: 'Ser',
    age: 31,
    isStudent: true
};

// * Цикл for in - нужен для Объекта - получаем ключ:значение
// Иногда во время работы необходимо перебрать все свойства и методы объекта и для этого есть цикл for in

// Создаём цикл for и переменную(название любое), в которую будем помещать наш ключ, далее прописываем in и указываем объект, который нужно перебрать, в примере это obj_1
for (let key in obj_1) {
    console.log('Ключ ' + key + '. ' + 'Значение: ' + obj_1[key] + '.');
}

// * Есть способ собрать все ключи нашего объекта в Массив и как-то ими оперировать. Делается это благодаря глобальному объекту Object.
// В данном примере мы обращаемся к глобальному объекту Object, к его методу keys и отдаём аргументом наш объект obj_1
console.log(Object.keys(obj_1));

// * Цикл for of - нужен для Массива - поочерёдно получаем каждй элемент Массива
let array_6 = ['One', 22, 33, 44, 'Five'];

// Создаём цикл for и переменную(название любое), в которую будем помещать наш ключ, далее прописываем of и указываем Массив, который нужно перебрать, в примере это array_6
for (let key of array_6) {
    console.log(key);
}

// Если мы попробуем перебрать Массив через for in, то Массив вернёт индексы
for (let key in array_6) {
    console.log(key);
}

// Возвращает значение из Массива
for (let key in array_6) {
    console.log(array_6[key]);
}

// * Оператор delete
// Нужен для того, чтобы удалять элементы из Массива и объектов, но на объект и на Массив он работает немного по разному

// Удаляем элемент из Массива
let array_7 = [1, 2, 3, 4, 'Five'];

delete array_7[2]; // Удаляет значение и оставляет пустоту, длина и индексы остаются

console.log(array_7);

// Удаляем элемент из объекта
let obj_7 = {
    name: 'Ser',
    age: 31
};

delete obj_7.age; // Удаляет ключ:значение из объекта полностью

console.log(obj_7);




// * ПседвоМассивы - не имеют методов для работы с Массивами
// * arguments - в современном стандартне ВООБЩЕ не используется

// По своей структуре похожи на Массивы, у них есть длина, элементы пронумерованы индексом, но у них нет самого важного - методов для работы с Массивами
const func = function (a, b, c) {
    console.log(arguments); // arguments псевдоМассив собирает в себя все возможные аргументы, даже если в параметре они не приняты
    console.log(a + b + c);
};

func(2, 5, 25);