'use strict';

// * Циклы - всего два типа это Рекурсия и Циклические операторы


//  * Чистка Картофеля через Рекурсию
// Рекурсия в современном JS используется крайне редко, так как она доовльно опасна. Если мы немного ошибёмся с условием, мы можем запустить функцию бесконечно количество раз, что поломает браузер и код


//  Дано 10 шт. картофеля, нужно почистить каждый
const potato1 = 10;

console.log('Картофель #1 почищен.');
console.log('Картофель #2 почищен.');
console.log('Картофель #3 почищен.');
console.log('Картофель #4 почищен.');
console.log('Картофель #5 почищен.');
console.log('Картофель #6 почищен.');
console.log('Картофель #7 почищен.');
console.log('Картофель #8 почищен.');
console.log('Картофель #9 почищен.');
console.log('Картофель #10 почищен.');

// Вариант выше не очень подходит, есть вариант сделать проще
const potato2 = 10;

const peelPotato2 = function (potatoIndex) {
    console.log('Картофель #' + potatoIndex + ' почищен.');
};

peelPotato2(potato2);

// Сделаем так, чтобы картофель был очищен, если он воообще есть > 0 и чтобы количество картофеля после чистки уменьшалось на единицу
const potato3 = 10;

const peelPotato3 = function (potatoIndex) {
    if (potatoIndex > 0) {
        console.log('Картофель #' + potatoIndex + ' почищен.');
        potatoIndex--; // Используем декримент, чтобы уменьшить количесту на единицу
        console.log(potatoIndex); // Выведет 9
        peelPotato3(potatoIndex); // Запускаем функцию внутри себя, что позволяет не плодить код и выполняет условие. Условие отрабатывает только в том случае, если картофель вообще есть и функция сама себя не запустит.
    } else {
        console.log('Ты почистил весь картофель, молодец!');
    }
};

peelPotato3(potato3);

// * Чистка картофеля через Циклические операторы
// Всего Циклических операторов 3:
// 1. Цикл for
// 2. Цикл while
// 3. Цикл do while


// * Цикл for принимает 3 парамера и состоит из тела цикла:
// 1. Стартовая точка, это тот индекс, с которого мы начнём прокручивать наш цикл
// 2. Условие по которому цикл будет выполняться
// 3. То действие, которое мы будем производить каждую итерацию(повторение цикла)
const potato4 = 10;

for (let i = 10; i > 0; i--) { // Цикл идёт на уменьшение, начинается с 10 до 1 и уменьшается на единицу
    console.log('Картофель #' + i + ' почищен.');
}

for (let i = 1; i < 11; i++) { // Цикл идёт на увеличение, начинается с 1 до 10 и увеличивается на единицу
    console.log('Картофель #' + i + ' почищен.');
}

// * Цикл while состоит из тела цикла и условия
//  Сначала думает, а потом делает

// Считается самым простым оператором в JS
// В () прописываем условие, при котором цикл будет повторяться. Пока это условие возвращает истину, цикл while будет отрабатывать
let potato5 = 10;

while (potato5 > 0) { // В () прописываем условие, при котором цикл будет повторяться, так как мы будем изменять potato5, то нужно объявить potato5 через let
    console.log('Картофель #' + potato5 + ' почищен.');
    potato5--;
}

// * Цикл do while является братом близнецом цикла while
//  Сначала делает, а потом думает

// В отличии от while, цикл do while обязательно отработает один раз, а только после этого он проверит условие и если это условие вернёт нам истину, то он отработает ещё раз и так раз за разом, пока условие не вернёт ложь
let potato6 = 10;

do {
    console.log('Картофель #' + potato6 + ' почищен.'); // Первая отработка цикла, после которого он начнёт проверку и добирается до условия
    potato6--;
} while (potato6 > 0);

// * Отмена работы цикла for
const potato7 = 10;

// Вариант 1 через continue - пропускаем
for (let i = 1; i < 11; i++) {
    if (i === 5) continue; // Пропускаем один из индексом, в этом примере это 5
    console.log('Картофель #' + i + ' почищен.');
}

// Вариант 2 через break - останавливаем
for (let i = 1; i < 11; i++) {
    if (i === 5) break; // Останавливает цикл на однои из индксов, в этом примере это 5
    console.log('Картофель #' + i + ' почищен.');
}

// * Вариант 3 через !== - пропускаем (более популярный способ)
for (let i = 1; i < 11; i++) {
    if (i !== 5) console.log('Картофель #' + i + ' почищен.'); // Будем выводить в консаоль всегда, когда индекс не равен 5
}

// * Полезные методы из урока 5

// Метод isNaN() - если значение будет NaN, то вернёт true, в другом случае false
console.log(isNaN(2)); // вернёт false
console.log(isNaN(5)); // вернёт false
console.log(isNaN(5 * '5 sss')); // вернёт true

// Метод trim() - убирает пробелы слева и справа от первого и последнего символа строки и за символ он действительно принимает введённый символ игнорируя пробелы
console.log('     '.trim().length);
console.log('   s sdds ss  '.trim());

// Метод isFinite - проверяет является ли переданное значением конечным числом, не пропускает строку, которая не является числом
console.log(isFinite(2)); // вернёт true
console.log(isFinite('5')); // вернёт true
console.log(isFinite('5' * 5)); // вернёт true
console.log(isFinite('5 asdasd')); // вернёт false
console.log(isFinite('5 asdasd' + 5)); // вернёт false